#light
//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace ExampleGraph
    #nowarn "49" // uppercase argument names
    #nowarn "67" // this type test or downcast will always hold
    #nowarn "66" // this upcast is unnecessary - the types are identical
    #nowarn "58" // possible incorrect indentation..
    #nowarn "57" // do not use create_DelegateEvent
    #nowarn "51" // address-of operator can occur in the code
    
    exception ReturnExceptionc1d71b4ec7ef42b8896a84f63fccaf9f of obj
    exception ReturnNoneExceptionc1d71b4ec7ef42b8896a84f63fccaf9f
    
    type
        IStep1 = interface
            
            abstract Compute : Microsoft.FSharp.Core.Tuple<int, int> * CnCRuntime.IInputCollection<int, int[,]> * CnCRuntime.IOutputCollection<int, int> * CnCRuntime.ITagCollection<int> -> CnCRuntime.CnCReturn
        end
    
    and
        IStep2 = interface
            
            abstract Compute : int * CnCRuntime.IInputCollection<int, int> -> CnCRuntime.CnCReturn
        end
    
    and
        IStep3 = interface
            
            abstract Compute : int * CnCRuntime.IOutputCollection<int, int> -> CnCRuntime.CnCReturn
        end
    
    and
        IStep4 = interface
            
            abstract Compute : obj * CnCRuntime.IOutputCollection<int, int> -> CnCRuntime.CnCReturn
        end
    
    and
        IExampleGraph = interface
            inherit CnCRuntime.Graph
            abstract B : CnCRuntime.IItemCollection<int, int> with get
            
            abstract A : CnCRuntime.IItemCollection<int, int[,]> with get
            
            abstract C : CnCRuntime.IItemCollection<int, int> with get
            
            abstract Tag1 : CnCRuntime.ITagCollection<Microsoft.FSharp.Core.Tuple<int, int>> with get
            
            abstract Tag2 : CnCRuntime.ITagCollection<int> with get
            
        end
    
    and
        
        Tag1 = class
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_Step1:IStep1
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_graph:IExampleGraph
            new(graph:IExampleGraph, Step1:IStep1) as this =
                {
                } then
                    this.m_graph <- graph
                    this.m_Step1 <- Step1
            abstract Put : Microsoft.FSharp.Core.Tuple<int, int> -> unit
            default this.Put  (tag:Microsoft.FSharp.Core.Tuple<int, int>) =
                let mutable tag = tag
                let tag = tag
                CnCRuntime.PutTag(this.m_graph, 
                                                                                                                    System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step1.Compute(tag, this.m_graph.A, this.m_graph.B, this.m_graph.Tag2))) |> ignore
            interface CnCRuntime.ITagCollection<Microsoft.FSharp.Core.Tuple<int, int>> with
                member this.Put  (tag:Microsoft.FSharp.Core.Tuple<int, int>) =
                    let mutable tag = tag
                    let tag = tag
                    CnCRuntime.PutTag(this.m_graph, 
                                                                                                                        System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step1.Compute(tag, this.m_graph.A, this.m_graph.B, this.m_graph.Tag2))) |> ignore
            end
        end
    
    and
        
        Tag2 = class
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_Step2:IStep2
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_Step3:IStep3
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_graph:IExampleGraph
            new(graph:IExampleGraph, Step2:IStep2, Step3:IStep3) as this =
                {
                } then
                    this.m_graph <- graph
                    this.m_Step2 <- Step2
                    this.m_Step3 <- Step3
            abstract Put : int -> unit
            default this.Put  (tag:int) =
                let mutable tag = tag
                let tag = tag
                CnCRuntime.PutTag(this.m_graph, 
                                                                                                                    System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step2.Compute(tag, this.m_graph.B))) |> ignore
                CnCRuntime.PutTag(this.m_graph, 
                                                                                                                    System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step3.Compute(tag, this.m_graph.C))) |> ignore
            interface CnCRuntime.ITagCollection<int> with
                member this.Put  (tag:int) =
                    let mutable tag = tag
                    let tag = tag
                    CnCRuntime.PutTag(this.m_graph, 
                                                                                                                        System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step2.Compute(tag, this.m_graph.B))) |> ignore
                    CnCRuntime.PutTag(this.m_graph, 
                                                                                                                        System.Func<unit,CnCRuntime.CnCReturn>(fun _ -> this.m_Step3.Compute(tag, this.m_graph.C))) |> ignore
            end
        end
    
    and
        
        ExampleGraph = class
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_ic:System.Threading.CountdownEvent
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_itemC_B:CnCRuntime.IItemCollection<int, int>
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_itemC_A:CnCRuntime.IItemCollection<int, int[,]>
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_itemC_C:CnCRuntime.IItemCollection<int, int>
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_tagC_Tag1:CnCRuntime.ITagCollection<Microsoft.FSharp.Core.Tuple<int, int>>
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_tagC_Tag2:CnCRuntime.ITagCollection<int>
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_stepC_Step1:IStep1
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_stepC_Step2:IStep2
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_stepC_Step3:IStep3
            
            [<Microsoft.FSharp.Core.DefaultValueAttribute(false)>]
            val mutable m_stepC_Step4:IStep4
            new() as this =
                {
                }
            interface IExampleGraph with
            
            member self.B with get() = self.m_itemC_B
            
            member self.A with get() = self.m_itemC_A
            
            member self.C with get() = self.m_itemC_C
            
            member self.Tag1 with get() = self.m_tagC_Tag1
            
            member self.Tag2 with get() = self.m_tagC_Tag2
            
            member self.outstandingTasks with get() = self.m_ic
            
            end
            static member Create  (Step1:IStep1, Step2:IStep2, Step3:IStep3, Step4:IStep4) =
                let mutable Step1 = Step1
                let mutable Step2 = Step2
                let mutable Step3 = Step3
                let mutable Step4 = Step4
                let mutable (g:ExampleGraph) = new ExampleGraph()
                g.m_stepC_Step1 <- Step1
                g.m_stepC_Step2 <- Step2
                g.m_stepC_Step3 <- Step3
                g.m_stepC_Step4 <- Step4
                g.m_itemC_B <- new CnCRuntime.ItemCollection<int, int>()
                g.m_itemC_A <- new CnCRuntime.ItemCollection<int, int[,]>()
                g.m_itemC_C <- new CnCRuntime.ItemCollection<int, int>()
                g.m_tagC_Tag1 <- new Tag1(g, Step1)
                g.m_tagC_Tag2 <- new Tag2(g, Step2, Step3)
                g.m_ic <- new System.Threading.CountdownEvent(1)
                ((g :> obj) :?> IExampleGraph)
        end